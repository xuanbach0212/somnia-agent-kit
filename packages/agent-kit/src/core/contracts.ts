import { ethers } from 'ethers';
import type {
  AgentRegistry,
  AgentManager,
  AgentExecutor,
  AgentVault,
} from '../../../../contracts/typechain-types';

// Import factories (these will be generated by typechain)
import {
  AgentRegistry__factory,
  AgentManager__factory,
  AgentExecutor__factory,
  AgentVault__factory,
} from '../../../../contracts/typechain-types';

export interface ContractInstances {
  agentRegistry: AgentRegistry;
  agentManager: AgentManager | null;
  agentExecutor: AgentExecutor;
  agentVault: AgentVault | null;
}

export interface ContractAddresses {
  agentRegistry: string;
  agentExecutor: string;
  agentManager?: string;
  agentVault?: string;
}

/**
 * SomniaContracts
 * Manages contract instances and provides type-safe access to deployed contracts
 */
export class SomniaContracts {
  private provider: ethers.Provider;
  private signer: ethers.Signer | null = null;
  private addresses: ContractAddresses;
  private instances: ContractInstances | null = null;

  constructor(
    provider: ethers.Provider,
    addresses: ContractAddresses,
    signer?: ethers.Signer
  ) {
    this.provider = provider;
    this.addresses = addresses;
    if (signer) {
      this.signer = signer;
    }
  }

  /**
   * Initialize contract instances
   */
  async initialize(): Promise<void> {
    const signerOrProvider = this.signer || this.provider;

    // Initialize required contracts
    const agentRegistry = AgentRegistry__factory.connect(
      this.addresses.agentRegistry,
      signerOrProvider
    );

    const agentExecutor = AgentExecutor__factory.connect(
      this.addresses.agentExecutor,
      signerOrProvider
    );

    // Initialize optional contracts
    let agentManager: AgentManager | null = null;
    if (this.addresses.agentManager) {
      agentManager = AgentManager__factory.connect(
        this.addresses.agentManager,
        signerOrProvider
      );
    }

    let agentVault: AgentVault | null = null;
    if (this.addresses.agentVault) {
      agentVault = AgentVault__factory.connect(
        this.addresses.agentVault,
        signerOrProvider
      );
    }

    this.instances = {
      agentRegistry,
      agentManager,
      agentExecutor,
      agentVault,
    };
  }

  /**
   * Get AgentRegistry contract instance
   */
  get AgentRegistry(): AgentRegistry {
    if (!this.instances) {
      throw new Error('Contracts not initialized. Call initialize() first.');
    }
    return this.instances.agentRegistry;
  }

  /**
   * Get AgentManager contract instance
   */
  get AgentManager(): AgentManager {
    if (!this.instances) {
      throw new Error('Contracts not initialized. Call initialize() first.');
    }
    if (!this.instances.agentManager) {
      throw new Error('AgentManager contract not configured');
    }
    return this.instances.agentManager;
  }

  /**
   * Get AgentExecutor contract instance
   */
  get AgentExecutor(): AgentExecutor {
    if (!this.instances) {
      throw new Error('Contracts not initialized. Call initialize() first.');
    }
    return this.instances.agentExecutor;
  }

  /**
   * Get AgentVault contract instance
   */
  get AgentVault(): AgentVault {
    if (!this.instances) {
      throw new Error('Contracts not initialized. Call initialize() first.');
    }
    if (!this.instances.agentVault) {
      throw new Error('AgentVault contract not configured');
    }
    return this.instances.agentVault;
  }

  /**
   * Check if contracts are initialized
   */
  isInitialized(): boolean {
    return this.instances !== null;
  }

  /**
   * Get all contract addresses
   */
  getAddresses(): Readonly<ContractAddresses> {
    return Object.freeze({ ...this.addresses });
  }

  /**
   * Update signer (e.g., when switching accounts)
   */
  async updateSigner(signer: ethers.Signer): Promise<void> {
    this.signer = signer;
    // Re-initialize contracts with new signer
    await this.initialize();
  }

  /**
   * Get contract instances (for advanced usage)
   */
  getInstances(): Readonly<ContractInstances> | null {
    return this.instances ? Object.freeze({ ...this.instances }) : null;
  }
}
